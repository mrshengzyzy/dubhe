package space.zyzy.dubhe.leetcode.topk;

import java.util.Arrays;

/**
 * Top K 问题
 * （1）有10000000个记录,这些查询串的重复度比较高,如果除去重复后,不超过3000000个。一个查询串的重复度越高,说明查询它的用户越多,也就是越热门。请统计最热门的10个查询串,要求使用的内存不能超过1GB。
 * （2）有10个文件,每个文件1GB,每个文件的每一行存放的都是用户的query,每个文件的query都可能重复。按照query的频度排序。
 * （3）有一个1GB大小的文件,里面的每一行是一个词,词的大小不超过16个字节,内存限制大小是1MB。返回频数最高的100个词。
 * （4）提取某日访问网站次数最多的那个IP。
 * （5）10亿个整数找出重复次数最多的100个整数。
 * （6）搜索的输入信息是一个字符串,统计300万条输入信息中最热门的前10条,每次输入的一个字符串为不超过255B,内存使用只有1GB。
 * （7）有1000万个身份证号以及他们对应的数据,身份证号可能重复,找出出现次数最多的身份证号。
 * ==================================================================================================
 * 一般来说这种问题分为两步解决
 * 1、统计每个数据的频次
 * 2、找出频次TopK
 * ==================================================================================================
 * 针对步骤1解决方案：
 * (1)直接排序,全部排序之后统计Query次数
 * (2)哈希表,根据Query构造哈希表
 * ==================================================================================================
 * 针对步骤2解决方案：
 * (1)直接排序
 * (2)过滤排序
 * (3)堆
 * ==================================================================================================
 */
public class TopK {

    public static void main(String[] args) {

        // 使用1亿数据做演示
        int count = 100000000;
        int[] data = DataAccess.get(count);
        int[] data1 = Arrays.copyOfRange(data, 0, data.length);

        /*
         * 直接排序TopK将改变原始数组
         * 排序法结果[99999999,99999998,99999996,99999996,99999996,99999993,99999990,99999990,99999987,99999987]
         * 用时9067毫秒
         */
//        SortTopK.solve(data);

        /*
         * 部分排序TopK和堆排序TopK都不会改变原数组
         *
         * 部分排序法结果[99999999,99999998,99999996,99999996,99999996,99999993,99999990,99999990,99999987,99999987]
         * 用时107毫秒
         *
         * 堆排序法结果[99999996,99999999,99999996,99999998,99999996,99999990,99999993,99999987,99999990,99999987]
         * 用时108毫秒
         */
//        PartSortTopK.solve(data1);
//        HeapTopK.solve(data1);

        /*
         * 多线程TopK不会改变原数组
         * 多线程TopK结果[99999999,99999998,99999996,99999996,99999996,99999993,99999990,99999990,99999987,99999987]
         * 用时273毫秒
         */
        MultiThreadTopK.solve(data1);

        /*
         * 哈希表法计算的是数字频次TopK而不是数字本身TopK
         * 计算每个值的hashCode将耗费大量时间
         */
//        HashTableTopK.solveMap(HashTableTopK.map(data));

    }
}
